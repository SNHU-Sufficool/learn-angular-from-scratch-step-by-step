{
    "ast": null,
    "code": "import { Http, Headers, Request, RequestOptions } from '@angular/http';\nimport { JSONSearchParams } from './search.params';\nimport { ErrorHandler } from './error.service';\nimport { LoopBackAuth } from './auth.service';\nimport { LoopBackConfig } from '../../lb.config';\nimport { LoopBackFilter } from '../../models/BaseModels';\nimport { SDKModels } from '../custom/SDKModels';\nimport { Subject } from 'rxjs';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/map';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/http\";\nimport * as i2 from \"../custom/SDKModels\";\nimport * as i3 from \"./auth.service\";\nimport * as i4 from \"./search.params\";\nimport * as i5 from \"./error.service\";\n/**\n* @module BaseLoopBackApi\n* @author Jonathan Casarrubias <@johncasarrubias> <github:jonathan-casarrubias>\n* @author Nikolay Matiushenkov <https://github.com/mnvx>\n* @license MIT\n* @description\n* Abstract class that will be implemented in every custom service automatically built\n* by the sdk builder.\n* It provides the core functionallity for every API call, either by HTTP Calls or by\n* WebSockets.\n**/\nexport let BaseLoopBackApi = /*#__PURE__*/(() => {\n  class BaseLoopBackApi {\n    http;\n    models;\n    auth;\n    searchParams;\n    errorHandler;\n    path;\n    model;\n    constructor(http, models, auth, searchParams, errorHandler) {\n      this.http = http;\n      this.models = models;\n      this.auth = auth;\n      this.searchParams = searchParams;\n      this.errorHandler = errorHandler;\n      this.model = this.models.get(this.getModelName());\n    }\n    /**\n     * @method request\n     * @param {string}  method      Request method (GET, POST, PUT)\n     * @param {string}  url         Request url (my-host/my-url/:id)\n     * @param {any}     routeParams Values of url parameters\n     * @param {any}     urlParams   Parameters for building url (filter and other)\n     * @param {any}     postBody    Request postBody\n     * @return {Observable<any>}\n     * @description\n     * This is a core method, every HTTP Call will be done from here, every API Service will\n     * extend this class and use this method to get RESTful communication.\n     **/\n    request(method, url, routeParams = {}, urlParams = {}, postBody = {}, pubsub = false, customHeaders) {\n      // Transpile route variables to the actual request Values\n      Object.keys(routeParams).forEach(key => {\n        url = url.replace(new RegExp(\":\" + key + \"(\\/|$)\", \"g\"), routeParams[key] + \"$1\");\n      });\n      if (pubsub) {\n        console.info('SDK: PubSub functionality is disabled, generate SDK using -io enabled');\n      } else {\n        // Headers to be sent\n        let headers = new Headers();\n        headers.append('Content-Type', 'application/json');\n        // Authenticate request\n        this.authenticate(url, headers);\n        // Body fix for built in remote methods using \"data\", \"options\" or \"credentials\n        // that are the actual body, Custom remote method properties are different and need\n        // to be wrapped into a body object\n        let body;\n        let postBodyKeys = typeof postBody === 'object' ? Object.keys(postBody) : [];\n        if (postBodyKeys.length === 1) {\n          body = postBody[postBodyKeys.shift()];\n        } else {\n          body = postBody;\n        }\n        let filter = '';\n        // Separate filter object from url params and add to search query\n        if (urlParams.filter) {\n          if (LoopBackConfig.isHeadersFilteringSet()) {\n            headers.append('filter', JSON.stringify(urlParams.filter));\n          } else {\n            filter = `?filter=${encodeURIComponent(JSON.stringify(urlParams.filter))}`;\n          }\n          delete urlParams.filter;\n        }\n        // Separate where object from url params and add to search query\n        /**\n        CODE BELOW WILL GENERATE THE FOLLOWING ISSUES:\n        - https://github.com/mean-expert-official/loopback-sdk-builder/issues/356\n        - https://github.com/mean-expert-official/loopback-sdk-builder/issues/328\n        if (urlParams.where) {\n          headers.append('where', JSON.stringify(urlParams.where));\n          delete urlParams.where;\n        }\n        **/\n        if (typeof customHeaders === 'function') {\n          headers = customHeaders(headers);\n        }\n        this.searchParams.setJSON(urlParams);\n        let request = new Request(new RequestOptions({\n          headers: headers,\n          method: method,\n          url: `${url}${filter}`,\n          search: Object.keys(urlParams).length > 0 ? this.searchParams.getURLSearchParams() : null,\n          body: body ? JSON.stringify(body) : undefined,\n          withCredentials: LoopBackConfig.getRequestOptionsCredentials()\n        }));\n        return this.http.request(request).map(res => res.text() != \"\" ? res.json() : {}).catch(e => this.errorHandler.handleError(e));\n      }\n    }\n    /**\n     * @method authenticate\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @param {string} url Server URL\n     * @param {Headers} headers HTTP Headers\n     * @return {void}\n     * @description\n     * This method will try to authenticate using either an access_token or basic http auth\n     */\n    authenticate(url, headers) {\n      if (this.auth.getAccessTokenId()) {\n        headers.append('Authorization', LoopBackConfig.getAuthPrefix() + this.auth.getAccessTokenId());\n      }\n    }\n    /**\n     * @method create\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @param {T} data Generic data type\n     * @return {Observable<T>}\n     * @description\n     * Generic create method\n     */\n    create(data, customHeaders) {\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path].join('/'), undefined, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method createMany\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @param {T[]} data Generic data type array\n     * @return {Observable<T[]>}\n     * @description\n     * Generic create many method\n     */\n    createMany(data, customHeaders) {\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path].join('/'), undefined, undefined, {\n        data\n      }, null, customHeaders).map(datum => datum.map(data => this.model.factory(data)));\n    }\n    /**\n     * @method findById\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @param {any} data Generic data type\n     * @return {Observable<T>}\n     * @description\n     * Generic findById method\n     */\n    findById(id, filter = {}, customHeaders) {\n      let _urlParams = {};\n      if (filter) _urlParams.filter = filter;\n      return this.request('GET', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, ':id'].join('/'), {\n        id\n      }, _urlParams, undefined, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method find\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T[+>}\n     * @description\n     * Generic find method\n     */\n    find(filter = {}, customHeaders) {\n      return this.request('GET', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path].join('/'), undefined, {\n        filter\n      }, undefined, null, customHeaders).map(datum => datum.map(data => this.model.factory(data)));\n    }\n    /**\n     * @method exists\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T[]>}\n     * @description\n     * Generic exists method\n     */\n    exists(id, customHeaders) {\n      return this.request('GET', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, ':id/exists'].join('/'), {\n        id\n      }, undefined, undefined, null, customHeaders);\n    }\n    /**\n     * @method findOne\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic findOne method\n     */\n    findOne(filter = {}, customHeaders) {\n      return this.request('GET', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'findOne'].join('/'), undefined, {\n        filter\n      }, undefined, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method updateAll\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T[]>}\n     * @description\n     * Generic updateAll method\n     */\n    updateAll(where = {}, data, customHeaders) {\n      let _urlParams = {};\n      if (where) _urlParams.where = where;\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'update'].join('/'), undefined, _urlParams, {\n        data\n      }, null, customHeaders);\n    }\n    /**\n     * @method deleteById\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic deleteById method\n     */\n    deleteById(id, customHeaders) {\n      return this.request('DELETE', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, ':id'].join('/'), {\n        id\n      }, undefined, undefined, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method count\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<{ count: number }>}\n     * @description\n     * Generic count method\n     */\n    count(where = {}, customHeaders) {\n      let _urlParams = {};\n      if (where) _urlParams.where = where;\n      return this.request('GET', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'count'].join('/'), undefined, _urlParams, undefined, null, customHeaders);\n    }\n    /**\n     * @method updateAttributes\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic updateAttributes method\n     */\n    updateAttributes(id, data, customHeaders) {\n      return this.request('PUT', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, ':id'].join('/'), {\n        id\n      }, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method upsert\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic upsert method\n     */\n    upsert(data = {}, customHeaders) {\n      return this.request('PUT', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path].join('/'), undefined, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method upsertPatch\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic upsert method using patch http method\n     */\n    upsertPatch(data = {}, customHeaders) {\n      return this.request('PATCH', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path].join('/'), undefined, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method upsertWithWhere\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic upsertWithWhere method\n     */\n    upsertWithWhere(where = {}, data = {}, customHeaders) {\n      let _urlParams = {};\n      if (where) _urlParams.where = where;\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'upsertWithWhere'].join('/'), undefined, _urlParams, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method replaceOrCreate\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic replaceOrCreate method\n     */\n    replaceOrCreate(data = {}, customHeaders) {\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'replaceOrCreate'].join('/'), undefined, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method replaceById\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<T>}\n     * @description\n     * Generic replaceById method\n     */\n    replaceById(id, data = {}, customHeaders) {\n      return this.request('POST', [LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, ':id', 'replace'].join('/'), {\n        id\n      }, undefined, {\n        data\n      }, null, customHeaders).map(data => this.model.factory(data));\n    }\n    /**\n     * @method createChangeStream\n     * @author Jonathan Casarrubias <t: johncasarrubias, gh: mean-expert-official>\n     * @license MIT\n     * @return {Observable<any>}\n     * @description\n     * Generic createChangeStream method\n     */\n    createChangeStream() {\n      let subject = new Subject();\n      if (typeof EventSource !== 'undefined') {\n        let emit = msg => subject.next(JSON.parse(msg.data));\n        var source = new EventSource([LoopBackConfig.getPath(), LoopBackConfig.getApiVersion(), this.model.getModelDefinition().path, 'change-stream'].join('/'));\n        source.addEventListener('data', emit);\n        source.onerror = emit;\n      } else {\n        console.warn('SDK Builder: EventSource is not supported');\n      }\n      return subject.asObservable();\n    }\n    static ɵfac = function BaseLoopBackApi_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BaseLoopBackApi)(i0.ɵɵinject(Http), i0.ɵɵinject(SDKModels), i0.ɵɵinject(LoopBackAuth), i0.ɵɵinject(JSONSearchParams), i0.ɵɵinject(ErrorHandler, 8));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: BaseLoopBackApi,\n      factory: BaseLoopBackApi.ɵfac\n    });\n  }\n  return BaseLoopBackApi;\n})();",
    "map": null,
    "metadata": {},
    "sourceType": "module",
    "externalDependencies": []
}
